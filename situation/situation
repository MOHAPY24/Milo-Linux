#!/bin/dash
# /bin/situation — dèrive/MiloLinux init and service manager

PATH="/bin:/sbin:/usr/bin:/usr/sbin"
export PATH

# Set ENV for mksh to source system configuration
ENV="/etc/mkshrc"
export ENV

echo "starting situation"

echo "mounting fs"
mount -n -t proc none /proc || {
    echo "failed to mount /proc"
    echo "dropping to emergency shell"
    exec /bin/sh
}

if ! mountpoint -q /sys 2>/dev/null; then
    mount -n -t sysfs none /sys || {
        echo "failed to mount /sys"
        echo "dropping to emergency shell"
        exec /bin/sh
    }
fi

if ! mountpoint -q /dev 2>/dev/null; then
    mount -n -t devtmpfs none /dev 2>/dev/null || {
        mount -n -t tmpfs dev /dev
        # Create essential device nodes if devtmpfs failed
        [ -c /dev/null ] || mknod -m 666 /dev/null c 1 3
        [ -c /dev/zero ] || mknod -m 666 /dev/zero c 1 5
        [ -c /dev/console ] || mknod -m 600 /dev/console c 5 1
        [ -c /dev/tty ] || mknod -m 666 /dev/tty c 5 0
    }
fi

#fix permissions on device nodes becasue devtmpfs may create with wrong perms
chmod 666 /dev/null /dev/zero /dev/tty 2>/dev/null

# create tty devices
mknod /dev/ttyS0 c 4 64 2>/dev/null || true
mknod /dev/tty1 c 4 1 2>/dev/null || true
chmod 620 /dev/ttyS0 /dev/tty1 2>/dev/null

# setup boot logging now that /dev exists
mkdir -p /var/log 2>/dev/null
# if [ -d /dev/fd ] && [ -w /var/log ]; then
#     exec 1> >(tee -a /var/log/boot 2>/dev/null) 2>&1
# fi

# create and mount additional essential filesystems
mkdir -p /dev/pts /dev/shm /run /tmp
mount -n -t devpts devpts /dev/pts 2>/dev/null || true
mount -n -t tmpfs tmpfs /dev/shm 2>/dev/null || true
mount -n -t tmpfs tmpfs /run 2>/dev/null || true
mount -n -t tmpfs tmpfs /tmp 2>/dev/null || true

# create utmp directory and file for login tracking
mkdir -p /var/run /var/log
touch /var/run/utmp /var/log/wtmp
chmod 664 /var/run/utmp /var/log/wtmp
chown root:root /var/run/utmp /var/log/wtmp

# remount root filesystem as read-write
echo "remounting root fs"
mount -n -o remount,rw / 2>/dev/null

# fix device permissions again after remount
chmod 666 /dev/null /dev/zero /dev/tty 2>/dev/null

# basic system setup
echo "configuring system"

# Read hostname from /etc/hostname if it exists
if [ -f /etc/hostname ]; then
    hostname "$(cat /etc/hostname)"
else
    hostname linux
fi

echo "/bin/sh" > /proc/sys/kernel/modprobe  # disable modprobe
echo 0 > /proc/sys/kernel/printk

# Allow unprivileged users to use ping via ICMP sockets (no setuid needed)
# This enables ping for all users without requiring capabilities or setuid
if [ -w /proc/sys/net/ipv4/ping_group_range ]; then
    echo "0 2147483647" > /proc/sys/net/ipv4/ping_group_range
fi

# Fix setuid permissions on security-sensitive binaries
# The kernel doesn't preserve setuid bits from initramfs for security
if [ -f /bin/doas ]; then
    chown root:root /bin/doas 2>/dev/null || true
    chmod 4755 /bin/doas 2>/dev/null || true
fi
if [ -f /etc/doas.conf ]; then
    chown root:root /etc/doas.conf 2>/dev/null || true
    chmod 600 /etc/doas.conf 2>/dev/null || true
fi

# setup device manager (if available)
echo "setting up devices"
if command -v smdev >/dev/null 2>&1; then
    [ -f /proc/sys/kernel/hotplug ] && echo /bin/smdev > /proc/sys/kernel/hotplug
    smdev -s
elif command -v mdev >/dev/null 2>&1; then
    [ -f /proc/sys/kernel/hotplug ] && echo /bin/mdev > /proc/sys/kernel/hotplug
    mdev -s
fi

# bring up loopback interface
if command -v ip >/dev/null 2>&1; then
    ip link set lo up
fi

# run local init scripts if any
[ -x /etc/rc.local ] && /etc/rc.local

# start services in sorted order with pid tracking
echo "starting services"
mkdir -p /etc/sv/pid
if [ -d /etc/sv/on ]; then
    for svc in $(ls /etc/sv/on/ 2>/dev/null | sort); do
        svc_path="/etc/sv/on/$svc"
        [ -x "$svc_path" ] || continue
        # Get the actual service name from symlink target
        svc_name=$(basename "$(readlink "$svc_path")")
        echo "starting $svc_name"
        "$svc_path" &
        echo $! > "/etc/sv/pid/$svc_name.pid"
    done
fi

# spawn console on serial and VGA with respawning
echo "spawning getty"

# wait a moment for devices to settle
sleep 1

if command -v getty >/dev/null 2>&1; then
    # BusyBox getty: getty [OPTIONS] BAUD_RATE TTY [TERMTYPE]
    # Serial console (for -nographic) - respawn if dies
    (
        while :; do
            setsid /bin/getty -L 115200 ttyS0 2>&1
            sleep 1  # prevent rapid respawn on persistent failure
        done
    ) &

    # VGA console - respawn if dies
    (
        while :; do
            setsid /bin/getty -L 38400 tty1 2>&1
            sleep 1  # prevent rapid respawn on persistent failure
        done
    ) &
else
    # Fallback: just exec a shell on console
    echo "getty not found"
    echo "starting emergency shell"
    exec /bin/sh
fi

# handle shutdowns
shutdown_system() {
    echo "shutting down"

    # Stop services in reverse order using saved PIDs
    if [ -d /etc/sv/pid ]; then
        echo "stopping services"
        for pidfile in $(ls -r /etc/sv/pid/*.pid 2>/dev/null); do
            pid=$(cat "$pidfile" 2>/dev/null)
            svc=$(basename "$pidfile" .pid)
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                echo "stopped $svc (pid $pid)"
                kill -TERM "$pid" 2>/dev/null
            fi
        done
        sleep 2
    fi

    # terminate all remaining processes
    echo "stopping everything else"
    killall5 -15
    sleep 2

    # force kill the rest
    sleep 1

    # unmount everything
    echo "unmounting fs"
    umount -ar 2>/dev/null
    sync

    echo "bye"
    poweroff -f
}
_local(){
	[ -f /etc/rc.local ]&&{
		echo 'running rc.local'
		/etc/rc.local
	}
}

trap 'shutdown_system' INT TERM
trap '' CHLD  # Ignore SIGCHLD to prevent zombie issues

echo "system ready"
_local
# 10. Idle loop (reap zombies)
while :; do
    wait
done
